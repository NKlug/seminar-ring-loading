\section{Introduction}

The ring loading problem first arose in the planning of \textbf{S}ynchronous \textbf{O}ptical \textbf{Net}working (SONET) rings.
In SONET, several add-drop multiplexers (ADMs) and other components are connected by mostly optical fibers.
One prominent SONET topology is the bidirectional path-switched ring, which is safe to the failure of a single link or node due to its connectivity.
In a SONET ring, the routing of node-to-node network traffic is fixed: The traffic between any two nodes is either always routed in the clockwise or the counter-clockwise direction.
The ring loading problem arises in the planning of SONET rings.
ADMs have a limited capacity of traffic they can send or receive through any link.
Hence the maximal workload on any link must be determined from estimated node-to-node network traffic demands during planning.
This involves computing the optimal routing of these demands around the ring.
As it turns out, determining such a routing is quite difficult.

In their paper "The Ring Loading Problem" from 1999, the Schrijver, Seymour and Winkler~\cite{schrijver99} derived an approximation algorithm for the ring loading problem.
Parts of this paper are presented and discussed here.

We begin by formalizing the problem.
The SONET ring is modeled by an undirected cycle graph consisting of $n \in \N$ nodes.
We number the nodes consecutively in the counter-clockwise direction with the numbers $1, 2, \dots, n$.
For the ease of notation, it makes sense to interpret the node numbers as representatives of the equivalence classes of $\Z/n\Z$.
This means that we can write the edge set as $E = \{\{i, i+1\}\ |\ i \in [n]\}$.
Now, for every two nodes $i \neq j$ we are given a (traffic) demand $d_{i, j} \in \R_{\geq 0}$, which represents the traffic that has to be routed through from node $i$ to node $j$.
In practice, the demands from $i$ to $j$ and $j$ to $i$ can differ.
However, XYZ have shown that we can without loss of generality combine these two demands into one single demand from $i$ to $j$ and still obtain the same optimal routing.
Thus, we focus on the case where for every two nodes $i < j$, we have one demand $d_{i,j}$.

A demand $d_{i, j}$ can be routed two ways around the ring.
We say that a demand is routed \emph{forward} or \emph{through the front}, if it does not use the edge $\{n, 1\}$.
Otherwise, we say that the demand is routed \emph{backwards} or \emph{through the back}.

Next, we can formally define routings in a ring of size $n$.
\begin{definition}[Routing]
	\label{def:routing}
	A \emph{real routing} is a function 
	\begin{equation}
		\Phi: \{(i, j)\ | \ 1 \leq i < j \leq n\} \rightarrow [0, 1] \ .
	\end{equation}
	A \emph{binary routing}, or simply \emph{routing}, is a real routing $\Phi$ only takes values in $\{0, 1\}$. 
\end{definition}
We interpret the value $\Phi(i, j)$ as the fraction of the demand $d_{i, j}$ that is routed through the front.

\begin{definition}[Edge load, Ringload]
	\label{def:edge-load}
	Let $\Phi$ be a (real) routing.
	For every edge $\{k, k+1\}$, $k \in [n]$, we define the \emph{load} $L_k$ as the total traffic that is routed through that edge:
	\begin{equation}
		\label{eq:edge-load}
		L_k(\Phi) \coloneqq \sum_{\substack{i < j\\ k \in [i, j)}} d_{i, j} \Phi(i, j) + \sum_{\substack{i < j\\ k \notin [i, j)}} d_{i, j} (1 - \Phi(i, j)) \ .
	\end{equation}
	The \emph{ringload} $L(\Phi)$ is the maximal load under the routing $\Phi$.
\end{definition}
In \cref{def:edge-load}, we have $k \in [i, j)$ if and only if the edge $\{k, k+1\}$ lies on the front route of the demand $d_{i, j}$.


With these preparations, we can now formulate the ring loading problem in mathematical terms:
\begin{center}
	\begin{mdframed}
		\centering
		\textsc{Ring Loading} (\textsc{RL})\\[0.7em]
		\begin{tabular}{rl}
			{\bfseries Input}: & Ring size $n \in \N$ and demands $d_{i, j}$ for all $1 \leq i<j\leq n$.\\
			{\bfseries Output}: & Binary routing $\Phi$ that minimizes $L = \max_{i \in [n]} L_i(\Phi)$.
		\end{tabular}
	\end{mdframed}
\end{center}
If we omit any zero demands, we can encode an instance of \RL in (approximately) $\cO(k)$ space, where $k \in N$ is the number of non-zero demands.

\RL can be formulated 
As mentioned above, \RL is an NP-complete problem.
\begin{theorem}
	\RL is NP-complete.
\end{theorem}
\begin{proof}
	A routing provides a 
\end{proof}



Already shown: Tight bound $L^\mathrm{opt} \leq 2 L^\ast$ (take references from dÃ¤ubel intro!! TODO).

\citet{schrijver99} achieve an additive bound of $L^\mathrm{opt} + \frac{3}{2}D$.
This bound has since been improved to $1.3$ but the improvement based on the same algorithm.
It is therefore still sensible to review and understand the algorithm presented by \citet{schrijver99} in the late 1990s.

The authors of \cite{schrijver99} claim that their algorithm runs in $O(k n^2)$, where $k$ is the number of non-zero demands.

In this work, I show that the ideas presented by \citet{schrijver99} can be extended to obtain an algorithm that runs in $\cO(n^2)$.
This is almost optimal, as the encoding length of an instance is in $\Theta(k)$ and in the worst case $k = \binom{n}{2} \in \cO(n^2)$.
The modified algorithm strongly relies on the principles of dynamic programming and uses a different, more efficient way of routing demands.


This seems to be a novel result which is interesting for several reasons:
\begin{itemize}
	\item The best currently known runtime for computing an $L^\mathrm{opt} + \frac{3}{2}D$ approximation to \RL is $O(k n^2)$.
	The proposed algorithm improves this runtime by a factor of $k$.
	\item The best currently known algorithm for solving \RRL with integer demands is $O(k + t_k)$ for integer demands, where $t_k$ is the time for sorting $k$ integers.
	For real demands, the best known runtime is $O(\min\{kn, n^2\})$.
	The proposed algorithm also works for real demands and almost matches the runtime of the latter algorithm.
	\item The proposed algorithm computes the same solution to \RL and \RRL as Schrijver et al.'s algorithm, which is particularly aesthetic in the sense that at most $\lfloor\frac{n}{2}\rfloor$ demands are split while the others are routed all front or all back.
	This means that the runtimes of all algorithms that use Schrijver et al.'s algorithm as a subroutine are improved as well, in particular that of the $(1 + \epsilon)$ algorithm by \citet{khanna97}.
\end{itemize}
