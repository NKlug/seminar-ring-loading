\section{Introduction}

The ring loading problem first arose in the planning of \textbf{S}ynchronous \textbf{O}ptical \textbf{Net}working rings.
In SONET, several add-drop multiplexers (ADMs) and other components are connected by mostly optical fibers.
One possible SONET topology is the bidirectional path-switched ring, which are safe to the failure of a single link or node due to their connectivity.
In a SONET ring, the routing of node-to-node network traffic is fixed: The traffic between any two nodes is either always routed in the clockwise or the counter-clockwise direction.
The ring loading problem arises in the planning of SONET rings.
ADMs have a limited capacity of traffic they can send or receive through any link.
Hence the maximal workload on any link must be determined from estimated node-to-node demands during planning.
This involves computing the optimal routing of these demands around the ring.
As it turns out, determining such a routing is NP-complete.

In their paper "The Ring Loading Problem" from 1999, the authors Schrijver, Seymour and Winkler \cite{schrijver99} derived an approximation algorithm for the ring loading problem.
Parts of this paper are presented and discussed here.

We begin by formalizing the problem.
The SONET ring is modeled through an undirected cycle graph consisting of $n \in \N$ nodes $V \coloneqq [n]$ and $n$ edges $E \coloneqq \{\{i, i+1\}\ |\ i \in [n-1]\} \cup \{\{n, 1\}\}$.
For every two nodes $i \neq j$ we are given a non-negative demand $d_{i, j}$.
In practice, the demands from $i$ to $j$ and $j$ to $i$ can differ.
As XYZ have shown, we can without loss of generality combine these two demands into one single demand from $i$ to $j$ and still obtain the same optimal routing.

A routing can then be defined as a function $\phi: \{(i, j)\ | \ 1 \leq i < j \leq n\} \rightarrow \{0, 1\}$.
For every edge (within the ring loading problem, edges are also referred to as links)  

Within the terminology of ring loading, the edges are also referred to as links.


Already shown: Tight bound $L^\mathrm{opt} \leq 2 L^\ast$ (take references from dÃ¤ubel intro!! TODO).

\citet{schrijver99} achieve an additive bound of $L^\mathrm{opt} + \frac{3}{2}D$.
This bound has since been improved to $1.3$ but the improvement based on the same algorithm.
It is therefore still sensible to review and understand the algorithm presented by \citet{schrijver99} in the late 1990s.

The authors of \cite{schrijver99} claim that their algorithm runs in $O(k n^2)$, where $k$ is the number of non-zero demands.

In this work, I show that the ideas presented by \citet{schrijver99} can be extended to obtain an algorithm that runs in $\cO(n^2)$.
This is almost optimal, as the encoding length of an instance is in $\Theta(k)$ and in the worst case $k = \binom{n}{2} \in \cO(n^2)$.
The modified algorithm strongly relies on the principles of dynamic programming and uses a different, more efficient way of routing demands.


This seems to be a novel result which is interesting for several reasons:
\begin{itemize}
	\item The best currently known runtime for computing an $L^\mathrm{opt} + \frac{3}{2}D$ approximation to \RL is $O(k n^2)$.
	The proposed algorithm improves this runtime by a factor of $k$.
	\item The best currently known algorithm for solving \RRL with integer demands is $O(k + t_k)$ for integer demands, where $t_k$ is the time for sorting $k$ integers.
	For real demands, the best known runtime is $O(\min\{kn, n^2\})$.
	The proposed algorithm also works for real demands and almost matches the runtime of the latter algorithm.
	\item The proposed algorithm computes the same solution to \RL and \RRL as Schrijver et al.'s algorithm, which is particularly aesthetic in the sense that at most $\lfloor\frac{n}{2}\rfloor$ demands are split while the others are routed all front or all back.
	This means that the runtimes of all algorithms that use Schrijver et al.'s algorithm as a subroutine are improved as well, in particular that of the $(1 + \epsilon)$ algorithm by \citet{khanna97}.
\end{itemize}
